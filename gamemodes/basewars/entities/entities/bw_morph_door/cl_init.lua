include("shared.lua")
AddCSLuaFile("shared.lua")

local sideData = "]\x00\x00\x01\x00\xd0<\x00\x00\x00\x00\x00\x00\x00;\x19J\xac\x0b\xd2\xbeXi#\xbf\xf1h\x96\xbe\\\xf9\x7fOS\xd4]\xdb\xec\xde\xff\x00[\x99\xeaY($b\xa6\xf1$h\xf6\xdd!\xe6\xca\x1dP\xc3D%\xa10\xc2\x9f\xad\xfc{4E\xc3\xd3\xe8\x98\x00\xa0\x88xc\xd3'\x89r\xdb\xf1\x00\xb1\xd0\x11	2\xf1@\xcez\x91\xfb:\xc7\xaa\xf9r\xf3\xe28|\xab\xb6.\x1d\x87Pe\x06onH\xa2\x98\x85\xd1\xf8\x13\xed7\x82s\xcb>@\xff\xfc\xcd\x9d\x99T\xba\xf6\xda\x8a\x13\x1aZ\
h\xb2\x95j\xe1?uB\xce\xa6.\x8eYt\r\xdd1H\x8bF\xfewG\xa1\xf5^:\x9ex\xb8\xfd\xa75Rk\x1djRR\xe5\xc8\x1cLL\xd6`\"\xec\xa7\xbf\xbf\x02\xc6\x14\x9aoD\x18G\xd5\xab\x13\xeb\xab\xf2\xdaU\xde\xb9\xa9\xfc\xf0\x90`I\xbf\x7f\xd5\xff\xee\x95V3\x82\x97\x12\x06	\xc1\xbc\x1b\xe3[9\x16\x95\x08\x17\xec'<\xd6\xbfd\x1f\x18\x97pC\x84r\x03\xb2[_\
\xd7\x16\x8b_\x0e\x83\xbb\xeb\xa3\x8e\xe7\x1d\xac:\x03|\x03|\xe4\xafL\xb8p\x04{l\xf7s\x81\xaf\xf8\x90\x83\x90\xd7r;\xc7\xb5C\xb7\xe6{\x17\xa0i\xb5\xea\x9cm~\xdf\x84\xb1\x91\x00\x0bJV\x89\x94\
*\x05\x9fC\x0f\xe9>\xcd\xc8\xa4\xac\x11\x8c\x95~\x91\xafFU\xbb\x7f>\xfa\xc9\xff\xf8\x9b\xaf\xcb\xfb\x11\x1c Q\xf9|\xd0\x87\x91\xba/sa\xe9\xf6\xbb\x93\xe8\xbf\xbd\xd5\x91X}%=\x8c\x89xtQ\xce\xf8ds{\\\xee\
\x83Z\xe3\xb2\xbd\xf4zU3\x84x\xdd	\x85\x8d\xbfX5\xd5G6)\xdb\xbb\xd6U\x8fU	\xe1\xd3\x0e\x04;VI=?\x10\xdc\xcf!\xe9\x95`c\x1cz\xc6\xa2\x96\xa4o\x98\xb8\x8a\x1d\xdc\x11\x9f\xb4\x80*\xa0\xc4\x03\x0c\xe1\xdc\xc2\xf8\xc4\x9c\x03\xd1@\xa5bk\xe7P\x0f\xfb\x99\xe0\x8a\x92\x94\"G\xfb\xc0^^\x8cB\xbb>\xa8\xf3\x11\x8dA\x89EM\rx\xd1\x99/\x93\xb2#P\xa3~\x03\xe3W\x9d\xfac_\r\xca\xde\xbch\x16\x8aN\x9e\xf7\x14z\xaf'u\xf6\xc6\xb1\x83\xd8\x17\x9b\xcfar3\x8b\xda\x0f\x82\xf5@``\xe68{\xf6cf\xf2\x98~G\xb8q>\xfe\x15B*\xf7\xf7\xa0!0|\xfc\x04$\xbd\xb2o\x9dt\xe7\x831I]73&\xce\x8a\xa1k\xe6,#\xb1\xf9-\xab'\xd8\xdf*\xc0B\x89\xc7X\x1f\xe1\xaa\xcfD\x92\xd1\xa3*\xb5\x1a\xf2\xf2s\x0e\xc8\x1e\x0b\xa9\xc5dFU\xaei\xb5\x8eY\x92\xa43\x96\xb1\xbf<;'\xa1\x05T\x81\xde\xf1_\xdfX\xa9^\xdb\x7f\x19F\xb0\xd4?\xd13}\xbe@'\xe5\x94\x8eZ\x9c\x9b\xaaVU\xfax\xcd\x16W&\x1a6\xd3\xc1\x9e\x15U\x07_\xc8}%\
\xb7oF\x93\
1`v(\xcbS\xac\x8c\xc9\x8c\xc9eC\x8a\xdf\x94\xed\xcd_\xbfj\xb34\xf80\xfe\x00\x94d\x97\xb6\xc5d\x80%\x1dA\xb2y\xa6\xf7\xca\x84\xf4\xd9w\x08\xfb\xee\xa4\xd1\x87D-\xcaN\x98b\x8aD%\xe5\x06\xb8H\xbauU\xf8;:K\xf3]\xbb\xa6\xee\xae\xa9\xd4\x931\
\xa9\xdcB\xf4\xad\xb3\xc6(\x91\x900\xfe$)\xdfi\x0ca\xd8\x91\x93z6.\x0e;\xadf\xe0\xa4b1[\xa5\xac\x11P\xa3d\x0ee\xac\xbe&rr\x8cz\x8f\x9c\xa8\xc5\x978\x0c\x9e\x8ej@\x07\xd9\xb4\x92-\x16\xcf\x93r\x91\x03a\xac\xa8\xa3\x19KD(<Tf\xe3cq2\xbc\x86\x8ew\xb4\xe7\x96e\xcbw\xdf\xe2\xc4\x95\xb4S\xed\xc3\r\x90\xcdp\x19\x19\xf2}N\x87\xd6v\xc6\xff\xa0\x02\xd0\x0fXj3\xd3\xdb\x04v'"
sideData = util.Decompress(sideData)

local doorData = "]\x00\x00\x01\x00\x81\x0c\x00\x00\x00\x00\x00\x00\x00;\x19J\xac\x0b\xd2\xbeXi#\xbf\xf1h\x96\xbe\\\xf9\x7fOS\xd4]\xdb\xec\xde\xff\x00[\x99\xeaY($b\xa6\xf1$h\xf6\xdd!\xe6\xca\x1dP\xc3D%\xa10\xc2\x9f\xad\xfc{4E\xc3\xd3\xe8\x98\x00\xa0\x88xc\xd3'\xfbWj\xf6ZC\\\x0bHZ=\x87C\xcaR\xf4\x06a\xd4\xa3O%\x93\xe1\xacLj\xea.\xa6\xdf\x99\x0ff\xb4\x97oG\x0f\xc79\xa0\x02O\xa2\xe6\x0e9\xe4M#\x91S\x94\xbb \x04;\xf0l\xa3[Q\xbd\x98\xb4\x1b\xbd\x93\xc7\x00\xc8\x85\x12\xf4F5'J\x95\x0e\xec\"fi\xcb\xb1%1\x865\x96\xaa\x13\x1e|V\xafx\x05\xb0l\xf1\xbe\x8e\xc5\x1bx\x06\xcb\x8aT\xa7\xea\x0c\x0e\xd288\xbc?\xb37\xd6U\xb3\xb1\xbf\x1d\x8d\x879%%\x19\x12\xea\xf9Z\xe1\xda\xf8V\xf5\x88n\x81\xab\x05M\x1c\xb9\x9e\xcaz4$\x02\x98'\xa4\x03\xe1\x90\xcdK\xbe=\xd7\x81\"\xa6\x1e\xea\xa81]\xdcT\xe3\xe3\xc1\xbc2\xcfb\x97Q\x92\x9d\xbbpQO\xa59\x83\xbeN\x11\xd9Z\xa4\xb0\x9f\x8c`D\xe8\xb6\xeb\xb7\xacg\xc7th\xfe\xa8\xa4\x1b3\xba\xe8@K\xd5\xea\x1b\xaa'\xceC\xd4\xa5\xda\x00\x86bD\x84\xd2y]$\xe8g\xa6\x8f\xd5A\xe4\xe8\xc6<5\xe6w?\xa1\x0b\x0fb\x9a\x95h/\x12hX\xf7\xce\x9e\x84f\xda\xfe(+~\xb2\xc9m\x8bw\xf0\x8b\xc9\xd4L\x81h\xf1\x9ab3\xd0\xf6\x9eoN\xd4"
doorData = util.Decompress(doorData)

local anim

function ENT:CLInit()
	anim = anim or Animatable("MorphDoors")

	local dist = self.Dists
	self:SetRenderBounds(Vector(-self.BoxThickness, -dist[1], -dist[2]), Vector(self.BoxThickness, dist[1], dist[2]), Vector(4, 4, 4))

	self.LeftClose = 0
	self.RightClose = 0
end

function ENT:OnOpen()
	anim = anim or Animatable("MorphDoors")

	anim:MemberLerp(self, "LeftClose", 0, 0.3, 0, 0.3)
	anim:MemberLerp(self, "RightClose", 0, 0.3, 0, 0.3)
end

function ENT:OnClose()
	anim = anim or Animatable("MorphDoors")

	anim:MemberLerp(self, "LeftClose", 1, 0.3, 0, 0.3)
	anim:MemberLerp(self, "RightClose", 1, 0.3, 0, 0.3)
end

local cols = {
	[true] = Colors.Green:Copy(),
	[false] = Colors.Red:Copy()
}

for k,v in pairs(cols) do
	v.a = 50
end

function ENT:GenerateMesh(vectbl)

	self.DoorMeshes = {
		Mesh(),
		Mesh(),
		Mesh()
	}

	local mshes = self.DoorMeshes

	local tris = smdparse(sideData, true)
	if not tris then error("Fuck") return end

	self.SMD = tris

	local bounds, dists = self:GetBounds()

	local l = {}
	local r = {}

	for name, triangles in pairs(tris) do
		local t = {}
		l[name] = t

		local t2 = {}
		r[name] = t2

		for k,v in ipairs(triangles) do
			local v1, v2 = Vector(), Vector()
			v1:Set(v.pos)
			v2:Set(v.pos)

			local n1, n2 = Vector(), Vector()
			n1:Set(v.normal)
			n2:Set(v.normal)

			t[k] = {
				pos = v1,
				normal = n1,
				u = v.u,
				v = v.v,
			}

			t2[k] = {
				pos = v2,
				normal = n2,
				u = v.u,
				v = v.v,
			}

		end
	end


	for k,v in pairs(r) do
		if k == "door_bottom" then

		elseif k == "door_top" then

		else
			local msh = mshes[3]
			local ang = Angle(0, -90, 0)
			local vec = Vector()


			for _, tri in ipairs(v) do
				local vec2 = Vector()
				vec2:Set(tri.pos)
				tri.pos = vec2
			end

			msh:BuildFromTriangles(v)
		end
	end

	local dtris = smdparse(doorData, true)
	if not dtris then error("What") return end

	for k,v in pairs(dtris) do
		local msh = mshes[2]

		for _, tri in ipairs(v) do
			local vec2 = Vector()
			vec2:Set(tri.pos)
			tri.pos = vec2
		end

		msh:BuildFromTriangles(v)
	end
end

local mat = Material( "models/debug/debugwhite" )
local wf = Material( "models/wireframe" )

local mtrx = Matrix()
local shang = Angle()
local scl = Vector(1, 1, 1)

function ENT:Draw()
	self:DrawModel()

	local pos = self:GetPos()

	local verts, vertDist, all_hit = self:GetBounds()

	local mins = Vector(-self.BoxThickness, -vertDist[2], vertDist[4])
	local maxs = Vector(self.BoxThickness, vertDist[1], -vertDist[3])

	OrderVectors(mins, maxs)

	render.SetColorMaterial()
	render.DrawQuad(verts[1], verts[3], verts[2], verts[4], cols[all_hit])

	local ang = self:GetAngles()
	render.DrawWireframeBox(pos, ang, mins, maxs, color_white)

	if self.DoorMeshes then
		render.SetMaterial(mat)
		mins.x = 0
		maxs.x = 0

		mtrx:Reset()
		mtrx:SetAngles(ang)
		mtrx:SetTranslation(pos)
		local boxDist = vertDist[3] + vertDist[4]
		local sc = boxDist / 36.785

		scl.x = 1
		scl.z = sc
		mtrx:SetScale(scl)

		mins.z = mins.z / sc
		mtrx:Translate(mins)
		shang.p = 0
		shang.y = 90
		shang.r = 0
		mtrx:Rotate(shang)

		cam.PushModelMatrix(mtrx)
			self.DoorMeshes[3]:Draw()
		cam.PopModelMatrix()


		maxs.z = maxs.z / sc

		mtrx:Reset()
		mtrx:SetAngles(ang)
		mtrx:SetTranslation(pos)
		mtrx:SetScale(scl)

		mtrx:Translate(maxs)
		shang.y = -90
		shang.r = 180
		mtrx:Rotate(shang)


		cam.PushModelMatrix(mtrx)
			self.DoorMeshes[3]:Draw()
		cam.PopModelMatrix()

		mtrx:Reset()
		mtrx:SetAngles(ang)
		mtrx:SetTranslation(pos)
		mtrx:SetScale(scl)

		mtrx:Translate(maxs)
		shang.y = -90
		shang.r = 180
		mtrx:Rotate(shang)


		cam.PushModelMatrix(mtrx)
			self.DoorMeshes[3]:Draw()
		cam.PopModelMatrix()

		shang.y = 90
		shang.p = 180
		shang.r = 0

		scl.x = math.abs(self.RightClose * (vertDist[1] - 6.66) / 1.344)

		mtrx:Reset()

		mtrx:Translate(pos)
		mtrx:Rotate(ang)

		mtrx:Scale(scl)
		mtrx:Translate(maxs - Vector(0, 6.66, 0))
		mtrx:SetScale(Vector(1, 1, 1))	-- yuck

		mtrx:Rotate(shang)

		mtrx:Scale(scl)


		shang.y = 90
		shang.p = 0

		render.SetMaterial(wf)

		cam.PushModelMatrix(mtrx)
			self.DoorMeshes[2]:Draw()
		cam.PopModelMatrix()

		scl.x = math.abs(self.LeftClose * (vertDist[2] - 6.66) / 1.344)

		mtrx:Reset()

		mtrx:Translate(pos)
		mtrx:Rotate(ang)

		mtrx:Scale(scl)
		mtrx:Translate(mins + Vector(0, 6.66, 0))
		mtrx:SetScale(Vector(1, 1, 1))	-- yuck

		mtrx:Rotate(shang)

		mtrx:Scale(scl)


		cam.PushModelMatrix(mtrx)
			self.DoorMeshes[2]:Draw()
		cam.PopModelMatrix()
	end
end


function ENT:Think()

end